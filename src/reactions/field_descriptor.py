# Copyright (C) 2025 Anthony (Lonnie) Hutchinson <chinacat@chinacat.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
'''
The basis of reactions is field change events. These are generated by
a descriptor that implements attribute access. The descriptor is implemented
in this package.

FieldDescriptor is the descriptor implementation. It uses ReactionsList to
track and call the reactions when field values change.
'''

from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import Callable, Iterable
from itertools import count
from typing import Any, overload

from .error import MustNotBeCalled


__all__ = ['FieldReaction']


type FieldReaction[T] = Callable[[Any, "FieldDescriptor[T]", T, T], None]
'''A method that is called when a field changes.'''


class Evaluatable[T](ABC):
    '''
    Base class for fields and predicates that can be evaluated.

    T is the type the evaluate() returns.
    '''

    @property
    @abstractmethod
    def fields(self) -> Iterable[FieldDescriptor[Any]]:
        raise NotImplementedError

    @abstractmethod
    def evaluate(self, instance: Any) -> T|None:
        '''
        Get the value of the type on instance.
        Field returns the instance value of the field.
        Predicates evaluate their truth value for the instance.
        '''
        raise NotImplementedError()


class _BoundField[T](ABC):
    '''Base class for BoundField (used for typing)'''
    @abstractmethod
    def react(self,instance: Any, field: FieldDescriptor[T], old: T, new: T
              ) -> None:
        raise NotImplementedError()

    @abstractmethod
    def reaction(self, reaction: FieldReaction[T]) -> None:
        ''' Add a reaction to the list of reactions.'''
        raise NotImplementedError()

class FieldDescriptor[T](Evaluatable[T], ABC):
    '''
    An instrumented field.
    - T: is the type of object the field references

    This is a descriptor that:
        - manages and tracks updates to the field value
        - provides predicates for comparisons of the field value

    This works by intercepting field accesses on the class to return the
    descriptor itself so that dunder comparison methods on the descriptor can
    create predicates that are wired to instance methods that react to changes.
    The changes are detected by __set__ on instances (rather than their types).

    The general flow is a class with a Field is created. Comparisons are done
    on the class Field attribute to specify predicates with reactions. The
    class is instantiated and values set on the field inspect the predicates
    and call them when the Fields they are composed of change.
    '''

    _field_count = count()  # class member for assigning default attr names

    def __init__(self,
                 initial_value: T,
                 classname: str|None = None,
                 attr: str|None = None,
                 *args: Any,  # todo moving this before the kwargs breaks things
                 **kwargs: Any) -> None:
        '''
        initial_value: The initial value for the field.
        classname: the name of the class this is a member of (display only)
        attr: the name of the attribute
        instance: the instance the field is attached to, None for Fields on
                  classes.
        *args, **kwargs: play nice with super()

        classname and attr are optional and will have meaningless values
        provided if not specified. They aren't required in order to keep field
        definitions simple and not repeat the class and name in the definition.
        Typically they will be filled in by FieldManager(Meta) during class
        definition.
        '''
        super().__init__(*args, **kwargs)
        self.set_names(classname or '<no class associated>',
                       attr or f'field_{next(self._field_count)}')
        self.initial_value: T = initial_value

        # Reactions is the list of reactions on the unbound field. BoundField
        # references this in a copy-on-write manner.
        self.reactions: list[FieldReaction[T]] = []

    def reaction(self, reaction: FieldReaction[T]) -> None:
        ''' Add a reaction to the list of reactions.'''
        self.reactions.append(reaction)

    @abstractmethod
    def _bind(self, nascent_instance: Any) -> _BoundField[T]:
        '''_bind the fields for the nascent_instance'''
        raise NotImplementedError()

    def set_names(self, classname: str, attr: str) -> None:
        '''
        Update the field with classname and attr.
        This is not implemented using __set_name__ because that happens when
        the class is being created which is after the predicate decorated
        methods on the class need to use the field. Using a metaclass with a
        custom namespace allows this to happen as soon as the field is added
        to the class namespace so any access happens after the field has
        been named.
        '''
        self.classname = classname
        self.attr = attr
        self._attr: str = '_' + self.attr               # private

    def __hash__(self) -> int:
        '''
        Make Field 'immutable' so that they can be used in sets. The id() of
        the field is its hash.
        '''
        return id(self)

    def evaluate(self, instance: Any) -> T:
        try:
            return getattr(instance, self._attr)
        except AttributeError:
            setattr(instance, self._attr, self.initial_value)
            return self.initial_value

    ###########################################################################
    # Descriptor protocol for intercepting field updates
    ###########################################################################
    @overload
    def __get__[Tf: FieldDescriptor[T]](self: Tf,
                                        instance: None,
                                        owner: Any)->Tf: ...

    @overload
    def __get__[Tf: FieldDescriptor[T]](self: Tf,
                                        instance: Any,
                                        owner: Any)->T: ...

    def __get__[Tf: FieldDescriptor[T]](self: Tf,
                                        instance: Any,
                                        owner: Any|None) -> T|Tf:
        '''
        Get the value of the field.

        For instances (instance is not None) this returns the actual value of
        the field.
        For classes (instance is None) the Field is returned so it can be used
        to create predicates.
        '''
        if instance is not None:
            return self.evaluate(instance)

        # Getting the field on the class. There are two cases that need to be
        # handled.
        #  1) Class.field for comparison
        #  2) dataclass initialization to set default value.
        # WTF did python conflate these two cases?
        # To handle this self is returned so case 1) uses the class field.
        # This means that instances of dataclass initialization receives this
        # Field as the 'default' value and it is set on the dataclass. This
        # case is handled in __set__ by detecting if "value is self" and
        # ignoring the call to __set__.
        assert owner is not None
        return self

    def __set__(self, instance: Any, value: T) -> None:
        # See comment in __get__ for handling field access. Ignore this call
        # if value is self.
        if value is self:
            return
        old: T = self.evaluate(instance)
        if value != old:
            setattr(instance, self._attr, value)
            try:
                bound_field = self.bound_field(instance)
            except AttributeError:
                # _bind the field on first access if the class doesn't do it
                # during initialization.
                bound_field = self._bind(instance)
            bound_field.react(instance, self, old, value)

    # end Descriptor protocol.
    ###########################################################################

    @abstractmethod
    def bound_field(self, instance: Any) -> _BoundField[T]:
        '''get the bound field for this field on instance'''
        raise NotImplementedError()

    __delete__ = MustNotBeCalled(
        None, "removal of state attributes is not permitted")

    @property
    def fields(self) -> Iterable[FieldDescriptor[T]]:
        yield self

    def __str__(self) -> str:
        return f"{self.classname}.{self.attr}"
    __repr__ = __str__


